import { describe, test, expect, beforeAll, afterAll } from "vitest";
import { execFile } from "node:child_process";
import { mkdtempSync, rmSync } from "node:fs";
import { tmpdir } from "node:os";
import { join, resolve } from "node:path";
import { isDockerAvailable } from "../helpers/docker-check.js";
import { buildApp } from "../../core/api/app.js";
import { validFixtures } from "../../spec/fixtures/index.js";
import type { FastifyInstance } from "fastify";
import type { PolicyConfig, TxIntent } from "../../core/types.js";

const dockerAvailable = await isDockerAvailable();

const DOCKERFILES_DIR = resolve(import.meta.dirname, "dockerfiles");

function buildImage(
  dockerfileName: string,
  tag: string,
): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    execFile(
      "docker",
      ["build", "-t", tag, "-f", `${DOCKERFILES_DIR}/${dockerfileName}`, DOCKERFILES_DIR],
      { timeout: 60000 },
      (error, stdout, stderr) => {
        if (error) reject(error);
        else resolve({ stdout, stderr });
      },
    );
  });
}

function removeImage(tag: string): Promise<void> {
  return new Promise((resolve) => {
    execFile("docker", ["rmi", "-f", tag], () => resolve());
  });
}

function restrictiveConfig(): PolicyConfig {
  return {
    version: "1",
    maxValueWei: "1000000",
    maxApprovalAmount: "1000000",
    contractAllowlist: ["0x2626664c2603336E57B271c5C0b26F421741e481"],
    tokenAllowlist: ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"],
    allowedChains: [8453],
    recipientAllowlist: [],
    maxRiskScore: 50,
    requireApprovalAbove: { valueWei: "0" },
    maxTxPerHour: 10,
  };
}

// ─── A1 & A2: Docker-based sandbox isolation tests ──────────────────────────

describe.skipIf(!dockerAvailable)("SecurityTest_A1 & A2: Sandbox skill isolation", () => {
  const IMAGE_KEYSTORE = "iscl-test-keystore:latest";
  const IMAGE_NETWORK = "iscl-test-network:latest";

  beforeAll(async () => {
    await Promise.all([
      buildImage("Dockerfile.keystore-test", IMAGE_KEYSTORE),
      buildImage("Dockerfile.network-test", IMAGE_NETWORK),
    ]);
  }, 120000);

  afterAll(async () => {
    await Promise.all([
      removeImage(IMAGE_KEYSTORE),
      removeImage(IMAGE_NETWORK),
    ]);
  });

  function runContainer(
    image: string,
  ): Promise<{ stdout: string; stderr: string; exitCode: number }> {
    return new Promise((resolve) => {
      execFile(
        "docker",
        [
          "run", "--rm",
          "--network", "none",
          "--read-only",
          "--memory", "64m",
          "--cpus", "0.5",
          "--tmpfs", "/tmp:rw,noexec,size=64m",
          "--security-opt", "no-new-privileges",
          "--cap-drop", "ALL",
          image,
        ],
        { timeout: 15000 },
        (error, stdout, stderr) => {
          resolve({ stdout, stderr, exitCode: error ? 1 : 0 });
        },
      );
    });
  }

  test("A1: Keystore paths absent in sandbox", async () => {
    const result = await runContainer(IMAGE_KEYSTORE);
    expect(result.stdout).toContain("KEYS_ABSENT");
  }, 30000);

  test("A2: External network request blocked in sandbox", async () => {
    const result = await runContainer(IMAGE_NETWORK);
    expect(result.stdout).toContain("NETWORK_BLOCKED");
  }, 30000);
});

// ─── A3: Approval summary generated by Core, not skill ─────────────────────

describe("SecurityTest_A3: Approval summary source of truth", () => {
  let app: FastifyInstance;
  let tempDir: string;

  beforeAll(async () => {
    tempDir = mkdtempSync(join(tmpdir(), "iscl-sec-a3-"));
    app = await buildApp({
      logger: false,
      auditDbPath: ":memory:",
      keystorePath: tempDir,
      policyConfig: restrictiveConfig(),
      promptFn: async () => true, // auto-approve in tests (no readline)
    });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
    rmSync(tempDir, { recursive: true, force: true });
  });

  test("approve-request description comes from Core builder, not intent metadata", async () => {
    const intent: TxIntent = {
      ...validFixtures.transfer,
      id: "550e8400-e29b-41d4-a716-44665544a300",
      metadata: {
        source: "attacker-skill",
        note: "ATTACKER_CONTROLLED_DESCRIPTION",
      },
    };

    const res = await app.inject({
      method: "POST",
      url: "/v1/tx/approve-request",
      payload: intent,
    });

    expect(res.statusCode).toBe(200);
    const body = res.json() as { description: string; txRequestHash: string };
    expect(body.description).not.toContain("ATTACKER_CONTROLLED_DESCRIPTION");
    expect(body.description).toContain("Transfer");
    expect(body.txRequestHash).toMatch(/^0x[0-9a-f]{64}$/);
  });

  test("txRequestHash is deterministic and cannot be spoofed", async () => {
    const intent1 = { ...validFixtures.transfer, id: "550e8400-e29b-41d4-a716-44665544a301" };
    const intent2 = { ...validFixtures.transfer, id: "550e8400-e29b-41d4-a716-44665544a301" };

    const res1 = await app.inject({ method: "POST", url: "/v1/tx/approve-request", payload: intent1 });
    const res2 = await app.inject({ method: "POST", url: "/v1/tx/approve-request", payload: intent2 });

    expect(res1.json().txRequestHash).toBe(res2.json().txRequestHash);
  });
});

// ─── A4: Policy denies malicious intents ────────────────────────────────────

describe("SecurityTest_A4: Policy denies malicious intents", () => {
  let app: FastifyInstance;
  let tempDir: string;

  beforeAll(async () => {
    tempDir = mkdtempSync(join(tmpdir(), "iscl-sec-a4-"));
    app = await buildApp({
      logger: false,
      auditDbPath: ":memory:",
      keystorePath: tempDir,
      policyConfig: restrictiveConfig(),
    });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
    rmSync(tempDir, { recursive: true, force: true });
  });

  test("unknown chain is denied", async () => {
    const intent: TxIntent = {
      ...validFixtures.transfer,
      id: "550e8400-e29b-41d4-a716-44665544a401",
      chain: { type: "evm", chainId: 999 },
    };

    const res = await app.inject({ method: "POST", url: "/v1/tx/build", payload: intent });
    expect(res.statusCode).toBe(403);
    expect(res.json().reasons.some((r: string) => r.includes("Chain 999"))).toBe(true);
  });

  test("unknown token is denied", async () => {
    const transferAction = validFixtures.transfer.action as { type: "transfer"; asset: { kind: "erc20"; address: string; symbol: string; decimals: number }; to: string; amount: string };
    const intent: TxIntent = {
      ...validFixtures.transfer,
      id: "550e8400-e29b-41d4-a716-44665544a402",
      action: {
        type: "transfer" as const,
        asset: {
          kind: "erc20" as const,
          address: "0x0000000000000000000000000000000000000bad",
          symbol: "SCAM",
          decimals: 18,
        },
        to: transferAction.to,
        amount: transferAction.amount,
      },
    };

    const res = await app.inject({ method: "POST", url: "/v1/tx/build", payload: intent });
    expect(res.statusCode).toBe(403);
    expect(res.json().reasons.some((r: string) => r.includes("Token"))).toBe(true);
  });

  test("unknown contract/spender is denied", async () => {
    const approveAction = validFixtures.approve.action as { type: "approve"; asset: { kind: "erc20"; address: string; symbol: string; decimals: number }; spender: string; amount: string };
    const intent: TxIntent = {
      ...validFixtures.approve,
      id: "550e8400-e29b-41d4-a716-44665544a403",
      action: {
        type: "approve" as const,
        asset: approveAction.asset,
        spender: "0x0000000000000000000000000000000000000bad",
        amount: approveAction.amount,
      },
    };

    const res = await app.inject({ method: "POST", url: "/v1/tx/build", payload: intent });
    expect(res.statusCode).toBe(403);
    expect(res.json().reasons.some((r: string) => r.includes("Contract"))).toBe(true);
  });

  test("value bomb exceeding limit is denied", async () => {
    const transferAction = validFixtures.transfer.action as { type: "transfer"; asset: { kind: "erc20"; address: string; symbol: string; decimals: number }; to: string; amount: string };
    const intent: TxIntent = {
      ...validFixtures.transfer,
      id: "550e8400-e29b-41d4-a716-44665544a404",
      action: {
        type: "transfer" as const,
        asset: transferAction.asset,
        to: transferAction.to,
        amount: "999999999999999999999999999",
      },
    };

    const res = await app.inject({ method: "POST", url: "/v1/tx/build", payload: intent });
    expect(res.statusCode).toBe(403);
    expect(res.json().reasons.some((r: string) => r.includes("exceeds max"))).toBe(true);
  });
});
